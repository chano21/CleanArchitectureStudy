
# 토론내용 : 1-2장

## 01. 계층형 아키텍처의 문제는 무엇일까?

### 올바르게 구축 된 계층형 아키텍처란?
각 계층은 응집도가 높으면서 다른계층과는 낮은 결합도를 가지고있는 구조  
계층간의 구분을 잘 나누어 설계되었다면 재사용률도 올라가고 테스트 진행이 수월해진다.

### 계층형 아키텍처의 웹 애플리케이션 구조
웹 계층 → 도메인 계층 → 영속성 계층  
웹 계층은 도메인 계층에 의존하고 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다. 이는 계층형 아키텍처의 ‘특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층만 접근하다’라는 유일한 규칙 때문이다.

**우리는 상태가 아니라 행동을 중심으로 모델링한다.**  
행동이 상태를 바꾸는 주체이기 때문이다.

### 계층형 아키텍처의 문제

**계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러가도록 용인한다. 아주 엄격한 자기 훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기가 어려워진다.**
- 만약 계층에서 상위 계층에 위치한 컴포넌트에 접근해야 하는 일이 생겼다고 보자.  
  간단하게 접근해야 할 컴포넌트를 계층 아래로 내려버리면 깔끔하게 문제가 해결된다.  
  그러나 이런일을 대수롭지 않게 반복하다보면 영속성 계층(최하단 계층)은 비대해지게 된다.

- 혹은 로직이 거의 필요하지 않는 경우 웹계층에서 바로 영속성 계층에 접근하는 방식으로 사이 계층을 건너뛰어 사용할 수 있다. 이는 웹 계층이 도메인계층의 로직을 구현하게 되어 계층의 구분이 사라지게 되고 웹계층에서 도메인계층뿐 아닌 영속성 계층에도 의존성이 생겨 결합도가 높아진다.
    - 웹 계층을 테스트 할 시 도메인 계층만 아닌 영속성 계층도 모킹을 해야하는 경우가 발생하며 단위테스트의 복잡도가 올라가게 된다.

    - 이처럼 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉬우며 나중에는 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워진 상태가 된다.

- 계층형 아키텍처는 도메인 서비스의 너비에 관한 규칙을 강제하지 않는다.  
  도메인 계층의 서비스가 다양한 일을 담당하게 되어 넓은 서비스가 생성된다면 영속성 계층에 많은 의존성을 갖게 되고 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.

  → 테스트하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.


<br/>

**동시작업의 어려움**  
**모든 상황에서 50명정도 되는 큰 규모의 개발팀이 10명 정도 되는 작은 규모의 개발팀보다 5배 빠를거라고 기대할 수는 없다.**

- 계층형 아키텍처는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을 만들어야 한다. 그렇기 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.
- 데이터 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여서 각 측면을 개별적으로 작업할 수 없기 때문이다.
- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다.

<br/>

**해결방법?**  
도메인 로직을 먼저 만들어야 한다. 그래야만 우리가 로직을 제대로 이해했는지 확인 할 수 있다.  
그리고 도메인 로직이 맞다는 것을 확인한 후에 이를 기반으로 영속성계층과 웹 계층을 만들어야 한다.  

**희망사항**  
고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 한다면 이런 작업들이 얼마나 수월해질까?



## 02. 의존성 역전하기

**단일 책임 원칙(=단일 변경 원칙)**
- 하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야한다.(= 단일 책임 원칙)
- ‘책임'은 사실 ‘오로지 한 가지 일만 하는 것' 보다는 ‘변경할 이유'로 해석해야 한다.(= 단일 변경 원칙)

만약 컴포넌트를 변경할 이유가 한가지라면 우리가 어떤 다른 이유로 스프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다.

> 한가지 변경할 이유라는 것이 아래같은 경우가 맞을까?  
> ⇒ 로그인기능은 로그인 방식이 변경될 때만 변경되어야하지 회원가입 방식이 변경되었다고 로그인 로직이 변경되면 안된다.

그러나 많은 코드는 단일 책임 원칙을 위반하기 때문에 시간이 갈수록 변경하기가 더 어려워지고(시간이 갈수록 컴포넌트를 변경할 더 많은 이유가 쌓임) 그로 인해 변경 비용도 증가한다.     
변경할 이유가 많이 쌓인 후에는 한 컴포넌트를 바꾸는 것이 다른 컴포넌트가 실패하는 원인으로 작용한다.

<br/>

책에서 클라이언트가 과거의 경험을 가지고 더 이상하고 비용이 많이 드는 방식을 주문하는 내용이 나왔다.  
실제로 핵심적인 특정 컴포넌트를 변경해야 하는 작업이 있다면 클라이언트는 위험성을 감수해야하기때문에 거절하는 경우가 많다.   
이 경우 추가하지 않아도 되는 로직을 추가하거나 모듈이 추가되는 경우도 많다. 이는 나중에 더 안좋은 설계가 생성되는 예시이기도 하다.  
⇒ 만약 임시적으로 사용하는 기능이라면 기존 모듈과 거의 유사한 로직이더라도 새로운 모듈을 만든느 것이 좋은 것일까?

**의존성 역전 원칙**  
계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다.   
단일 책임 원칙을 고수준에서 적용할 때 상위 계층들이 하위 계층들에 비해 변경할 이유가 더 많다는 것을 알 수 있다.   
그 말은 즉 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다는 말이다.   
**그러나 도메인 코드는 애플리케이션에서 가장 중요한 코드이기 때문에 바꾸고 싶지 않다.**  

**‘ 코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다.’**
- 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고 도메인 코드를 변경할 이유의 개수를 줄여보자.
- 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어야한다.
  즉, 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다는 뜻이다. 이는 도메인 계층과 다른 계층들 사이에서도 마찬가지다.
- 도메인 계층이 영속성이나 UI같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한모델을 각 계층에서 유지보수 해야한다.
- 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 한다. 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.

- 가장 중요한 규칙은 의존성 규칙으로, 계층간의 모든 의존성이 안쪽(코어)으로 향해야 한다는 것이다.


> 각 계층에서 엔티티를 관리하게 된다면 관리해야 할 객체가 많아진다 이것은 마냥 장점이 될 수 있을까?

<br>

**앞으로의 방향**  
의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함  
- 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다.
- 변경할 이유가 적을수록 유지보수성은 더 좋아진다.
- 이것이 바로 도메인 코드를 프레임워크에 특화된 문제로부터 해방시키고자 했던, 결합이 제거된 상태다.

<br/>

**육각형 아키텍처(헥사고날 아키텍처)** 
- 클린아키텍처에서 제시한 의존성 규칙이 그대로 적용되었다.
- 모든 의존성은 코어를 향한다.

**웹어댑터 → 코어(유스케이스(→엔티티)) → 영속성 어댑터**

왼쪽에 있는 어댑터들은(ex.웹어댑터) 애플리케이션 코어를 호출하기 때문에 애플리케이션을 주도하는 어댑터들이다. 반면 오른쪽에 있는 어댑터들은(ex.영속성 어댑터) 애플리케이션 코어에 의해 호출되기 때문에 애플리케이션에 의해 주도되는 어댑터들이다.

애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다. 주도하는 어댑터에게는 그러한 포트가 코어에 있는 유스케이스 클래스들에 의해 구현되고 호출되는 인터페이스가 될 것이고, 주도되는 어댑터에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다. ⇒ **포트와 어댑터 아키텍처**

<br/>
<br/>


관련된 게시물에 대해서도 많이 찾아보고 있는데 책의 서평 중에 육각형 아키텍처는 클린 아키텍처에 해당하지만 그렇다고 클린 아키텍처가 반드시 육각형 아키텍처(클린아키텍처 ≠ 육각형아키텍처)는 아니라는 글을 보았다. ([https://brunch.co.kr/@springboot/676](https://brunch.co.kr/@springboot/676)) 2단원에 대해서는 몇번 더 읽으며 이해해볼 필요가 있으며 좀 더 넓게 많이 알아가도록 노력해야겠다.
